!
! Copyright (C) 2001-2008 Quantum ESPRESSO group
! This file is distributed under the terms of the
! GNU General Public License. See the file `License'
! in the root directory of the present distribution,
! or http://www.gnu.org/copyleft/gpl.txt .
!
!
!----------------------------------------------------------------------------
SUBROUTINE gradcorr_large( rho, rhog, rho_core, rhog_core, etxc, vtxc, v )
  !----------------------------------------------------------------------------
  !
  USE constants,            ONLY : e2
  USE kinds,                ONLY : DP
  USE gvecl,                ONLY : ngm, g
  USE lsda_mod,             ONLY : nspin
  USE large_cell_base,            ONLY : omega, alat
  USE funct,                ONLY : gcxc, gcx_spin, gcc_spin, igcc_is_lyp, &
                                   gcc_spin_more, dft_is_gradient, get_igcc
  USE spin_orb,             ONLY : domag
  USE noncollin_module,     ONLY : ux
  USE fde, ONLY : psic => psic_large
  USE fft_base,             ONLY : dfftp => dfftl
  USE fft_interfaces,       ONLY : fwfft

  !
  IMPLICIT NONE
!hack2018 ["gradcorr", "PW/src/gradcorr.f90" , "subroutine"]
END SUBROUTINE gradcorr_large
!
!----------------------------------------------------------------------------
SUBROUTINE gradrho_large( nrxx, a, ngm, g, nl, ga )
  !----------------------------------------------------------------------------
  !
  ! ... Calculates ga = \grad a in R-space (a is in G-space)
  !
  USE kinds,     ONLY : DP
  USE constants, ONLY : tpi
  USE large_cell_base, ONLY : tpiba
  USE gvecl,     ONLY: nlm
  USE control_flags, ONLY : gamma_only
  USE fft_base,      ONLY : dfftp => dfftl
  USE fft_interfaces,ONLY : invfft

  !
  IMPLICIT NONE
!hack2018 ["gradrho", "PW/src/gradcorr.f90" , "subroutine"]
END SUBROUTINE gradrho_large
!
!----------------------------------------------------------------------------
SUBROUTINE gradient_large( nrxx, a, ngm, g, nl, ga )
  !----------------------------------------------------------------------------
  !
  ! ... Calculates ga = \grad a in R-space (a is also in R-space)
  !
  USE constants, ONLY : tpi
  USE large_cell_base, ONLY : tpiba
  USE kinds,     ONLY : DP
  USE gvecl,     ONLY : nlm
  USE control_flags, ONLY : gamma_only
  USE fft_base,      ONLY : dfftp => dfftl
  USE fft_interfaces,ONLY : fwfft, invfft
  !
  IMPLICIT NONE
!hack2018 ["gradient", "PW/src/gradcorr.f90" , "subroutine"]
END SUBROUTINE gradient_large
!----------------------------------------------------------------------------
SUBROUTINE exx_gradient( nrxx, a, ngm, g, nl, ga )
  !----------------------------------------------------------------------------
  !
  ! ... Calculates ga = \grad a in R-space (a is also in R-space, exx grid) 
  !
  USE constants, ONLY : tpi
  USE cell_base, ONLY : tpiba
  USE kinds,     ONLY : DP
  USE control_flags, ONLY : gamma_only
  USE exx,           ONLY : dfftt
  USE fft_interfaces,ONLY : fwfft, invfft
  !
  IMPLICIT NONE
  !
  INTEGER,  INTENT(IN)  :: nrxx
  INTEGER,  INTENT(IN)  :: ngm, nl(ngm)
  REAL(DP), INTENT(IN)  :: a(nrxx), g(3,ngm)
  REAL(DP), INTENT(OUT) :: ga(3,nrxx)
  !
  INTEGER                  :: ipol
  COMPLEX(DP), ALLOCATABLE :: aux(:), gaux(:)
  !
  !
  ALLOCATE(  aux( nrxx ) )
  ALLOCATE( gaux( nrxx ) )
  !
  aux = CMPLX( a(:), 0.D0 ,kind=DP)
  !
  ! ... bring a(r) to G-space, a(G) ...
  !
  CALL fwfft ('Rho', aux, dfftt)
  !
  ! ... multiply by (iG) to get (\grad_ipol a)(G) ...
  !
  DO ipol = 1, 3
     !
     gaux(:) = CMPLX(0.d0,0.d0, kind=dp)
     !
     gaux(nl(:)) = g(ipol,:) * &
                   CMPLX( -AIMAG( aux(nl(:)) ), REAL( aux(nl(:)) ) ,kind=DP)
     !
     IF ( gamma_only ) THEN
        !
        gaux(dfftt%nlm(:)) = CMPLX( REAL( gaux(nl(:)) ), -AIMAG( gaux(nl(:)) ) ,kind=DP)
        !
     END IF
     !
     ! ... bring back to R-space, (\grad_ipol a)(r) ...
     !
     CALL invfft ('Rho', gaux, dfftt)
     !
     ! ...and add the factor 2\pi/a  missing in the definition of G
     !
     ga(ipol,:) = tpiba * DBLE( gaux(:) )
     !
  END DO
  !
  DEALLOCATE( gaux )
  DEALLOCATE( aux )
  !
  RETURN
  !
END SUBROUTINE exx_gradient
!
!----------------------------------------------------------------------------
SUBROUTINE grad_dot_large( nrxx, a, ngm, g, nl, alat, da )
  !----------------------------------------------------------------------------
  !
  ! ... Calculates da = \sum_i \grad_i a_i in R-space
  !
  USE constants, ONLY : tpi
  USE large_cell_base, ONLY : tpiba
  USE kinds,     ONLY : DP
  USE gvecl,     ONLY : nlm
  USE control_flags, ONLY : gamma_only
  USE fft_base,      ONLY : dfftp => dfftl
  USE fft_interfaces,ONLY : fwfft, invfft
  !
  IMPLICIT NONE
!hack2018 ["grad_dot", "PW/src/gradcorr.f90", "subroutine"]
END SUBROUTINE grad_dot_large
!--------------------------------------------------------------------
SUBROUTINE hessian_large( nrxx, a, ngm, g, nl, ga, ha )
!--------------------------------------------------------------------
  !
  ! ... Calculates ga = \grad a in R-space 
  ! ... and ha = \hessian a in R-space (a is also in R-space)
  !
  USE constants, ONLY : tpi
  USE large_cell_base, ONLY : tpiba
  USE kinds,     ONLY : DP
  USE gvecl,     ONLY : nlm
  USE control_flags, ONLY : gamma_only
  USE fft_base,      ONLY : dfftp => dfftl
  USE fft_interfaces,ONLY : fwfft, invfft
  !
  IMPLICIT NONE
  !hack2018 ["hessian", "PW/src/gradcorr.f90" , "subroutine"]
END SUBROUTINE hessian_large

!--------------------------------------------------------------------
SUBROUTINE laplacian( nrxx, a, ngm, gg, nl, lapla )
!--------------------------------------------------------------------
  !
  ! ... Calculates lapla = \laplace a in R-space (a is also in R-space)
  !
  USE constants, ONLY : tpi
  USE cell_base, ONLY : tpiba2
  USE kinds,     ONLY : DP
  USE gvect,     ONLY : gstart
  USE control_flags, ONLY : gamma_only
  USE fft_base,      ONLY : dfftp
  USE fft_interfaces,ONLY : fwfft, invfft
  !
  IMPLICIT NONE
  !
  INTEGER,  INTENT(IN)  :: nrxx
  INTEGER,  INTENT(IN)  :: ngm, nl(ngm)
  REAL(DP), INTENT(IN)  :: a(nrxx), gg(ngm)
  REAL(DP), INTENT(OUT) :: lapla( nrxx )
  !
  INTEGER                  :: ig
  COMPLEX(DP), ALLOCATABLE :: aux(:), laux(:)
  !
  !
  ALLOCATE(  aux( nrxx ) )
  ALLOCATE( laux( nrxx ) )
  !
  aux = CMPLX( a(:), 0.D0 ,kind=DP)
  !
  ! ... bring a(r) to G-space, a(G) ...
  !
  CALL fwfft ('Rho', aux, dfftp)
  !
  ! ... Compute the laplacian
  !
  laux(:) = CMPLX(0.d0,0.d0, kind=dp)
  !
  DO ig = gstart, ngm
     !
     laux(nl(ig)) = -gg(ig)*aux(nl(ig))
     !
  END DO
  !
  IF ( gamma_only ) THEN
     !
     laux(dfftp%nlm(:)) = CMPLX( REAL(laux(nl(:)) ), -AIMAG(laux(nl(:)) ) ,kind=DP)
     !
  ENDIF
  !
  ! ... bring back to R-space, (\lapl a)(r) ...
  !
  CALL invfft ('Rho', laux, dfftp)
  !
  ! ... add the missing factor (2\pi/a)^2 in G
  !
  lapla = tpiba2 * DBLE( laux )   
  !
  DEALLOCATE( laux )
  DEALLOCATE( aux )
  !
  RETURN
  !
END SUBROUTINE laplacian

!--------------------------------------------------------------------
SUBROUTINE external_gradient( a, grada )
!--------------------------------------------------------------------
  ! 
  ! Interface for computing gradients in real space, to be called by
  ! an external module
  !
  USE kinds,            ONLY : DP
  USE fft_base,         ONLY : dfftp
  USE gvect,            ONLY : ngm, g
  !
  IMPLICIT NONE
  !
  REAL( DP ), INTENT(IN)   :: a( dfftp%nnr )
  REAL( DP ), INTENT(OUT)  :: grada( 3, dfftp%nnr )

! A in real space, grad(A) in real space
  CALL gradient( dfftp%nnr, a, ngm, g, dfftp%nl, grada )

  RETURN

END SUBROUTINE external_gradient

!--------------------------------------------------------------------
SUBROUTINE external_hessian( a, grada, hessa )
!--------------------------------------------------------------------
  ! 
  ! Interface for computing hessian in real space, to be called by
  ! an external module
  !
  USE kinds,            ONLY : DP
  USE fft_base,         ONLY : dfftp
  USE gvect,            ONLY : ngm, g
  !
  IMPLICIT NONE
  !
  REAL( DP ), INTENT(IN)   :: a( dfftp%nnr )
  REAL( DP ), INTENT(OUT)  :: grada( 3, dfftp%nnr )
  REAL( DP ), INTENT(OUT)  :: hessa( 3, 3, dfftp%nnr )

! A in real space, grad(A) and hess(A) in real space
  CALL hessian( dfftp%nnr, a, ngm, g, dfftp%nl, grada, hessa )

  RETURN

END SUBROUTINE external_hessian

!--------------------------------------------------------------------
SUBROUTINE external_laplacian( a, lapla )
!--------------------------------------------------------------------
  ! 
  ! Interface for computing laplacian in real space, to be called by 
  ! an external module
  !
  USE kinds,            ONLY : DP
  USE fft_base,         ONLY : dfftp
  USE gvect,            ONLY : ngm, gg
  !
  IMPLICIT NONE
  !
  REAL( DP ), INTENT(IN)   :: a( dfftp%nnr )
  REAL( DP ), INTENT(OUT)  :: lapla( dfftp%nnr )

! A in real space, lapl(A) in real space
  CALL laplacian( dfftp%nnr, a, ngm, gg, dfftp%nl, lapla )

  RETURN

END SUBROUTINE external_laplacian
!--------------------------------------------------------------------
